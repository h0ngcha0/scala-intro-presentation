| \gIntroduction to Scala

/\bðŸŒ‰ \s

| A Bridge Between

| Object Oriented Programming and Functional Programming
---
| \gIdeology War?

/\bðŸ˜  \s

--
\**\s Programmers just want \ymodularity\s and \yreusibility\s

--
\**\s Ability to take the code apart into small modules and put them
  together in a different way (Unix philosophy \bðŸ† \s).

--
\**\s OOP and FP both provide a set of abstractions to achieve that.

--
\**\s More languages are becoming hybrid, no silver bullet really.

---
\gObject Oriented Programming

/\b-\s

--
\**\s Based on the concept of \yobjects\s.

--
\**\s \yObjects\s may or may not contain data (\yattributes\s) or
  code (\ymethods\s).

--
\**\s \yMethods\s can get/set \yattributes\s within an \yobject\s.

--
\**\s Programs are made out of \yobjects\s interacting with each other.

---
\gOOP's take on modularity and reusibility

/\b-\s

--
\**\s \yObjects\s encapsulate complex internal structures and
  interact with each other using \ymessage passing\s or \ydynamic\s
  \ydispatch\s

--
\**\s Combine \yobjects\s with \yinheritance\s, \yobject\s composition\s,
  \ydelegation\s

--
\**\s Subtype polymorphism (seperation of concerns)

---
\gFunctional Programming

/\b-\s

--
\**\s Emphasize on \ypure functions\s (\yreferential transparency\s)

--
\**\s Promote simple and \yimmutable\s data structures (primitive data
  types and \yalgibraic data types\s)

--
\**\s Try to write large piece of side effects free code by composing
  pure functions.

--
\**\s \ySide effects\s are preferrably pushed as outmost as possible.

---
\gFP's take on modularity and reusibility

/\b-\s

--
\**\s \yPure functions\s are building blocks of the programs written
  in functional style.

--
\**\s No side effects, meaning that those blocks are independent of
  each other, making it easy to combine them together.

--
\**\s First class / higher order functions are the super glues that
  enables function composition.

--
\**\s Reusible in concurrent settings.

---
\g A simple example of function composition:

/\b-\s

--
```
def lowerCase(s: String) = s.filter(_.isLower)
```
--
```
def count(s: String) = s.length
```
--
```
def lowerCaseCount = count _ compose lowerCase _
```

--
```
lowerCaseCount("aBc")
```

---
\gCompare OOP and FP's attempts to modularity and reusibility

/\b-\s

--
\**\s Pure functions over simple data structures compose better than
  objects because objects are opaque data types that could be mutable.

--
\**\s OOP shines in domains where problems can be natually modelled as
  objects (w/o mutable states). e.g. GUI?, Actors (\rErlang OTP\s, Akka)

--
\**\s Still, suprisingly many problems can be solved by using simple
  data types with functions. Do the cost of modeling every problem
  with objects really makes up for the lost of composibility?

--
\**\s FP is sort of like turning objects inside out. '\yD\s'
  (Dependency Inversion) in the '\ySOLID\s' principle.

--
\**\s Both should have a place, (Scala \bðŸ˜ƒ \s).

---
\gScala is a pure OO language

/\b-\s

--
\**\s Everything is object

```
val i = 5  // no primitive types
assert(i.toString == "5")
```

--
```
val j = List(1,2,3)
assert(j.length == 3)
```

--
```
val date = new java.util.Date()  // java interop
```

---
\gScala is a pure OO language

/\b-\s

\**\s Java style classes

```
class Stack[T] {
   var elems: List[T] = List()
   def push(x: T) { elems = x :: elems }
   def top: T = elems.head
   def pop() { elems = elems.tail }
}

val stack = new Stack[Int]
```

---
\gScala is a pure OO language

/\b-\s

\**\s Object (singleton)

```
object Stack {
   def nickname = "LIFO"
}

Stack.nickname
```

---
\gScala is a pure OO language

/\b-\s

\**\s Traits

\rFIXME\s

--
\**\s traits is the combination of interface and mixins

---
\gScala is a pure OO language

/\b-\s

\**\s Function are objects

```
def multiIA(x: Int) = i * x
val multiIB = (x: Int) => i * x
assert(multiIA(2) == 10)
assert(multiIA(2) == multiIB(2))
```

--
```
val multiIC = new Function1[Int, Int] {
  def apply(x: Int): Int = i * x
}
assert(multiIB(2) == multiIC(2))
```

---
\gScala is a pure OO language

/\b-\s

\**\s The \yapply\s method

```
class Multiply(y: Int) {
   def apply(x: Int) = x * y
}

val multi5 = new Multiply(5)
assert(multi5(10) == 50)
```

--
\**\s \yapply\s closes the gap between functions and objects.

---
\gScala is a pure OO language

/\b-\s

\**\s Partial functions as objects

```
val one: PartialFunction[Int, String] = { case 1 => "one" }
```

--
```
val two: PartialFunction[Int, String] = { case 2 => "two" }
```

--
```
val rest: PartialFunction[Int, String] = {
   case 3 => "three"
   case _ => "rest..."
}
```

--
```
val all: PartialFunction[Int, String] = one orElse two orElse rest
```

---
\gScala is a pure OO language

/\b-\s

\*Pattern matching is very sweet...\s

--
```
3 match {
  case 1 => "one"
  case 2 => "two"
  case 3 => "three"
  case _ => "rest..."
}
```

--
\*and it is the sugar for\s

```
all(3)
```

---
\gScala is a pure OO language

/\b-\s

\**\s What is pattern matching
--
  \*-\s deconposition of a data type
--
  \*-\s apply partial function

--
\**\s Why pattern matching is ubiquitous in FP, but not OOP
--
  \*-\s FP focus on algebraic data types, decomposition is trivial.
--
  \*-\s OOP focus on objects, no \ystandard\s way to decompose.

---
\gScala is a pure OO language

/\b-\s
       
\**\s The \yunapply\s method
      
--
```
val some5: Option[Int] = Some(5)
val none: Option[Int] = None
```

--
```
class Person(val name: String, val gender: String, val title: String) {}
object Person {
  def unapply(p: Person) = Some((p.name, p.title))
}
```

--
```
val person = new Person("obama", "male", "president")
```

--
```
person match {
  case Person(name, title) => println(s"name: $name, title: $title")
}
```

---
\gScala is a pure OO language

/\b-\s

\**\s case classes

--
```
case class Country(capital: String, population: Double)
```

--
```
val sweden = Country("Gothenburg", 9.593)
```

--
```
sweden match {
  case Country(capital, population) =>
     println(s"capital: $capital :P, population: $population million")
}
```

--
```
Country.unapply(sweden)
```
